
import { HttpErrorResponse, HttpResponse } from '@angular/common/http';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { EventEmitter } from '@angular/core';
import { TestBed } from '@angular/core/testing';
import {
    AccessTokenApiResponse,
    AccessTokenControllerService,
    LoginApiRequest, LoginControllerService, LogoutControllerService,
    PasswordResetControllerService,
    PasswordUpdateApiRequest, PasswordUpdateControllerService,
    UserApiResponse
} from 'auth-api-sdk';
import { of, throwError } from 'rxjs';
import { UserSession } from '../session/user-session';
import { AuthenticationService } from './authentication.service';

describe('AuthenticationService', () => {

    let authenticationService: AuthenticationService;
    let userSession: UserSession;

    let accessTokenControllerService: AccessTokenControllerService;

    beforeEach(() => {
        TestBed.configureTestingModule({
            imports: [
                HttpClientTestingModule
            ],
            providers: [
                {
                    provide: UserSession,
                    useValue: {
                        setUser: () => { },
                        clearStaleSession: () => { },
                        user: {}
                    }
                }
            ]
        });

        accessTokenControllerService = TestBed.inject(AccessTokenControllerService);
        spyOn(accessTokenControllerService, 'getAccessToken').and.returnValue(of({ body: {}, status: 200 } as HttpResponse<AccessTokenApiResponse>));

        authenticationService = TestBed.inject(AuthenticationService);
        userSession = TestBed.get(UserSession);
    });

    it('should init', () => {
        expect(authenticationService).toBeTruthy();
        expect(accessTokenControllerService.getAccessToken).toHaveBeenCalledTimes(1);
    });
});

describe('AuthenticationService', () => {

    let authenticationService: AuthenticationService;
    let userSession: UserSession;

    let accessTokenControllerService: AccessTokenControllerService;
    let loginController: LoginControllerService;
    let logoutController: LogoutControllerService;
    let passwordResetControllerService: PasswordResetControllerService;
    let passwordUpdateControllerService: PasswordUpdateControllerService;
    let getAccessToken: EventEmitter<HttpResponse<AccessTokenApiResponse>>;

    beforeEach(() => {
        TestBed.configureTestingModule({
            imports: [
                HttpClientTestingModule
            ],
            providers: [
                {
                    provide: UserSession,
                    useValue: { setUser: () => { }, clearStaleSession: () => { } }
                }
            ]
        });

        accessTokenControllerService = TestBed.inject(AccessTokenControllerService);
        loginController = TestBed.inject(LoginControllerService);
        logoutController = TestBed.inject(LogoutControllerService);
        passwordUpdateControllerService = TestBed.inject(PasswordUpdateControllerService);
        passwordResetControllerService = TestBed.inject(PasswordResetControllerService);

        getAccessToken = new EventEmitter<HttpResponse<AccessTokenApiResponse>>();
        spyOn(accessTokenControllerService, 'getAccessToken').and.returnValue(getAccessToken);

        authenticationService = TestBed.inject(AuthenticationService);
        userSession = TestBed.get(UserSession);
    });

    it('should handle unathorized on refresh', async () => {
        spyOn(userSession, 'clearStaleSession');
        const observable = authenticationService.refreshUser();
        getAccessToken.error({ status: 401, statusText: '' } as HttpErrorResponse);
        expect(userSession.clearStaleSession).toHaveBeenCalledTimes(1);
    });

    it('should handle deactivated user on refresh', async () => {
        spyOn(userSession, 'clearStaleSession');
        const observable = authenticationService.refreshUser();
        getAccessToken.error({ status: 401, statusText: '', error: 'ACCOUNT_DEACTIVATED' } as HttpErrorResponse);
        expect(userSession.clearStaleSession).toHaveBeenCalledTimes(1);
    });

    it('should handle error on refresh', async () => {
        spyOn(userSession, 'clearStaleSession');
        authenticationService.refreshUser();
        getAccessToken.error({ status: 500, statusText: '', error: '' } as HttpErrorResponse);
        expect(userSession.clearStaleSession).not.toHaveBeenCalled();
    });

    it('should login', async () => {
        const accessTokenApiResponse: AccessTokenApiResponse = {
            id: 1,
            displayName: 'Lee',
            emailAddresses: ['olaleyeone@gmail.com'],
            data: [],
            passwordAutoGenerated: false
        };
        spyOn(userSession, 'setUser');
        spyOn(loginController, 'login').and.returnValue(of(accessTokenApiResponse as any));

        const loginApiRequest: LoginApiRequest = {
            identifier: 'lee',
            password: 'p@ssw0rd!'
        };
        const observable = authenticationService.login(loginApiRequest);
        await new Promise(resolve => observable.subscribe(resolve));
        expect(loginController.login).toHaveBeenCalledWith({ loginApiRequest });
        expect(loginController.login).toHaveBeenCalledTimes(1);

        expect(userSession.setUser).toHaveBeenCalledWith(accessTokenApiResponse);
        expect(userSession.setUser).toHaveBeenCalledTimes(1);
    });

    it('should logout for logged-in user', async () => {
        spyOn(userSession, 'clearStaleSession');
        spyOn(logoutController, 'logout').and.returnValue(of({} as any));

        const observable = authenticationService.logout();
        await new Promise(resolve => observable.subscribe(resolve));
        expect(logoutController.logout).toHaveBeenCalledTimes(1);

        expect(userSession.clearStaleSession).toHaveBeenCalledTimes(1);
    });

    it('should logout for inactive session', async () => {
        spyOn(userSession, 'clearStaleSession');
        spyOn(logoutController, 'logout').and.returnValue(throwError({ status: 401, statusText: '' } as HttpErrorResponse));

        const observable = authenticationService.logout();
        await new Promise(resolve => observable.subscribe(resolve));
        expect(logoutController.logout).toHaveBeenCalledTimes(1);

        expect(userSession.clearStaleSession).toHaveBeenCalledTimes(1);
    });

    it('should handle error on logout', async () => {
        spyOn(userSession, 'clearStaleSession');
        spyOn(logoutController, 'logout').and.returnValue(throwError({ status: 500, statusText: '' } as HttpErrorResponse));

        const observable = authenticationService.logout();
        await new Promise(resolve => observable.subscribe(resolve));
        expect(logoutController.logout).toHaveBeenCalledTimes(1);

        expect(userSession.clearStaleSession).not.toHaveBeenCalled();
    });

    it('should change password', async () => {

        userSession.updateUser = () => { };
        spyOn(userSession, 'updateUser');

        const userApiResponse: UserApiResponse = {
            id: 1,
            displayName: 'Lee',
            emailAddresses: ['olaleyeone@gmail.com'],
            identifiers: [],
            data: [],
            passwordAutoGenerated: false
        };
        spyOn(passwordUpdateControllerService, 'changePassword').and.returnValue(of(userApiResponse as any));

        const passwordUpdateApiRequest: PasswordUpdateApiRequest = {
            password: 'p@ssw0rd!',
            currentPassword: 'secret'
        };
        const observable = authenticationService.changePassword(passwordUpdateApiRequest.password, passwordUpdateApiRequest.currentPassword);
        await new Promise(resolve => observable.subscribe(resolve));
        expect(passwordUpdateControllerService.changePassword).toHaveBeenCalledWith({ passwordUpdateApiRequest });
        expect(passwordUpdateControllerService.changePassword).toHaveBeenCalledTimes(1);

        expect(userSession.updateUser).toHaveBeenCalledWith(userApiResponse);
        expect(userSession.updateUser).toHaveBeenCalledTimes(1);
    });

    it('should reset password without auto login', async () => {

        const accessTokenApiResponse: AccessTokenApiResponse = {
            id: 1,
            displayName: 'Lee',
            emailAddresses: ['olaleyeone@gmail.com'],
            data: [],
            passwordAutoGenerated: false
        };

        spyOn(userSession, 'setUser');

        spyOn(passwordResetControllerService, 'resetPasswordWithResetToken').and.returnValue(of(accessTokenApiResponse as any));

        const data = {
            identifier: 'olaleyeone@gmail.com',
            resetToken: '1234567890',
            password: 'secret'
        };
        const observable = authenticationService.resetPassword(data);
        await new Promise(resolve => observable.subscribe(resolve));
        expect(passwordResetControllerService.resetPasswordWithResetToken).toHaveBeenCalledWith({
            identifier: data.identifier,
            resetToken: data.resetToken,
            passwordResetApiRequest: {
                password: data.password
            }
        });
        expect(passwordResetControllerService.resetPasswordWithResetToken).toHaveBeenCalledTimes(1);

        expect(userSession.setUser).not.toHaveBeenCalled();
    });

    it('should reset password with auto login', async () => {

        const accessTokenApiResponse: AccessTokenApiResponse = {
            id: 1,
            displayName: 'Lee',
            emailAddresses: ['olaleyeone@gmail.com'],
            data: [],
            passwordAutoGenerated: false,
            access_token: 'abc'
        };

        spyOn(userSession, 'setUser');

        spyOn(passwordResetControllerService, 'resetPasswordWithResetToken').and.returnValue(of(accessTokenApiResponse as any));

        const data = {
            identifier: 'olaleyeone@gmail.com',
            resetToken: '1234567890',
            password: 'secret'
        };
        const observable = authenticationService.resetPassword(data);
        await new Promise(resolve => observable.subscribe(resolve));
        expect(passwordResetControllerService.resetPasswordWithResetToken).toHaveBeenCalledWith({
            identifier: data.identifier,
            resetToken: data.resetToken,
            passwordResetApiRequest: {
                password: data.password
            }
        });
        expect(passwordResetControllerService.resetPasswordWithResetToken).toHaveBeenCalledTimes(1);

        expect(userSession.setUser).toHaveBeenCalledWith(accessTokenApiResponse);
        expect(userSession.setUser).toHaveBeenCalledTimes(1);
    });

    it('should get user from token store', () => {
        expect(authenticationService.getUser()).toBe(userSession.user);
    });

});
